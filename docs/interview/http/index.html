<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Aoki 的自留地 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Aoki 的自留地 Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Aoki 的自留地" href="/opensearch.xml"><title data-react-helmet="true">[面试题] HTTP | Aoki 的自留地</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://phero.live/docs/interview/http"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="[面试题] HTTP | Aoki 的自留地"><meta data-react-helmet="true" name="description" content="1. HTTP 有哪些方法？"><meta data-react-helmet="true" property="og:description" content="1. HTTP 有哪些方法？"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://phero.live/docs/interview/http"><link data-react-helmet="true" rel="alternate" href="https://phero.live/docs/interview/http" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://phero.live/docs/interview/http" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BMRZNSN9O0-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.2b49098c.css">
<link rel="preload" href="/assets/js/runtime~main.8d5656ef.js" as="script">
<link rel="preload" href="/assets/js/main.0a6693fb.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbar--dark"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_TMUO themedImage--dark_uzRr"></div><b class="navbar__title">Aoki</b></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/intro">笔记</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/aokikoko" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_iYfV toggle_2i4l toggleDisabled_xj38"><div class="toggleTrack_t-f2" role="button" tabindex="-1"><div class="toggleTrackCheck_mk7D"><span class="toggleIcon_pHJ9">🌜</span></div><div class="toggleTrackX_dm8H"><span class="toggleIcon_pHJ9">🌞</span></div><div class="toggleTrackThumb_W6To"></div></div><input type="checkbox" class="toggleScreenReader_h9qa" aria-label="Switch between dark and light mode"></div><div class="searchBox_Utm0"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">我的知识库 😀</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/CSS/transition-animation-transform">CSS</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/DocusaurusTips/code-theme">Docusaurus使用技巧</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/TypeScript/basic-types">TypeScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/Cli/ESLint">Cli</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/DevOps/prometheus">DevOps</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/Http/OptionsRequest">Http</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/Linux/basic">Linux</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/Mysql/case">Mysql</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/Nginx/sign">Nginx</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/Node.js/buffer">Node.js</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/React/jsx">React</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_TwRn" href="/docs/interview/http">interview</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/interview/http">[面试题] HTTP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/js">[面试题] JS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/tcp">[面试题] TCP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/dom">[面试题] DOM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/webpack">[面试题] 工程化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/vue">[面试题] Vue</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/js1">[面试题] JS-基本数据类型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/js2">[面试题] JS-引用类型</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/function">[面试题] JS-函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/obj">[面试题] JS-对象常见问题</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/domevent">[面试题] JS-DOM与事件</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/ajax">[面试题] JS-ajax</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/interview/es6">[面试题] JS-ES6</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/javascript/ecma">javascript</a></div></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_eoK2"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_e+kA"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>[面试题] HTTP</h1></header><h2 class="anchor anchorWithStickyNavbar_y2LR" id="1-http-有哪些方法">1. HTTP 有哪些方法？<a class="hash-link" href="#1-http-有哪些方法" title="Direct link to heading">​</a></h2><p>HTTP 1.0 标准中，定义了 3 种请求⽅法：GET、POST、HEAD</p><p>HTTP 1.1 标准中，新增了请求⽅法：PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="2-各个-http-方法的具体作用是什么">2. 各个 HTTP 方法的具体作用是什么？<a class="hash-link" href="#2-各个-http-方法的具体作用是什么" title="Direct link to heading">​</a></h2><table><thead><tr><th align="center">方法</th><th>功能</th></tr></thead><tbody><tr><td align="center">GET</td><td>通常⽤于请求服务器发送某些资源</td></tr><tr><td align="center">POST</td><td>发送数据给服务器</td></tr><tr><td align="center">HEAD</td><td>请求资源的头部信息, 并且这些头部与 HTTP GET ⽅法请求时返回的⼀致。该请求⽅法的⼀个使⽤场景是在下载⼀个⼤⽂件前先获取其⼤⼩再决定是否要下载, 以此可以节约带宽资源</td></tr><tr><td align="center">PUT</td><td>⽤于全量修改⽬标资源 (看接口, 也可以用于添加)</td></tr><tr><td align="center">DELETE</td><td>⽤于删除指定的资源</td></tr><tr><td align="center">OPTIONS</td><td>⽤于获取⽬的资源所⽀持的通信选项 (跨域请求前, 预检请求, 判断目标是否安全)</td></tr><tr><td align="center">TRACE</td><td>该方法会 让服务器 原样返回任意客户端请求的信息内容, 用于诊断和判断</td></tr><tr><td align="center">CONNECT</td><td>HTTP/1.1 协议中预留给能够将连接改为管道⽅式的代理服务器(把服务器作为跳板，让服务器代替用户去访问其它网页, 之后把数据原原本本的返回给用户)</td></tr><tr><td align="center">PATCH</td><td>⽤于对资源进⾏部分修改</td></tr></tbody></table><p>GET POST PUT PATCH DELETE</p><p>GET/DELETE 参数是在地址栏中传递的</p><p>PUT/PATCH/POST 参数是在请求体传递的</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="3-get-方法和-post-方法有何区别">3. GET 方法和 POST 方法有何区别？<a class="hash-link" href="#3-get-方法和-post-方法有何区别" title="Direct link to heading">​</a></h2><p>默认的 http 请求的内容, 在网络中传输, 明文的形式传递的 (https 对内容加密)</p><table><thead><tr><th></th><th>GET 方法</th><th>POST 方法</th></tr></thead><tbody><tr><td><strong>数据传输⽅式</strong></td><td>通过 URL 传输数据 (地址栏拼接参数)</td><td>通过请求体传输</td></tr><tr><td><strong>数据安全</strong></td><td>数据暴露在 URL 中，可通过浏览历史记录、缓存等很容易查到数据信息</td><td>数据因为在请求主体内，<br>所以有⼀定的安全性保证</td></tr><tr><td><strong>数据类型</strong></td><td>只允许 ASCII 字符</td><td>⽆限制</td></tr><tr><td><strong>GET ⽆害</strong></td><td>刷新、后退等浏览器操作是⽆害的</td><td>可能会引起重复提交表单</td></tr><tr><td><strong>功能特性</strong></td><td>安全且幂等（这⾥的安全是指只读特性，就是使⽤这个⽅法不会引起服务器状态变化。<br><strong>幂等的概念是指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同）</strong></td><td>⾮安全(会引起服务器端的变化)、<strong>⾮幂等</strong></td></tr></tbody></table><h2 class="anchor anchorWithStickyNavbar_y2LR" id="4-http-请求报文是什么样的">4. HTTP 请求报文是什么样的？<a class="hash-link" href="#4-http-请求报文是什么样的" title="Direct link to heading">​</a></h2><p>HTTP 请求报⽂的组成：请求⾏、请求头、(空⾏)、请求体。</p><p>实际请求报文实例:</p><p><img alt="image-20210305232854139" src="/assets/images/image-20210305232854139-ccb8ecd25667b855c29b4fc25f764b4b.png"></p><p><strong>请求行</strong></p><p>包含了请求⽅法、URL、HTTP 协议版本，它们之间⽤空格进行分隔。例如：</p><div class="codeBlockContainer_J+bg language-bash theme-code-block"><div class="codeBlockContent_csEI bash"><pre tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#F8F8F2"><span class="token plain">GET http://www.abc.com/articles HTTP/1.1</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>请求头</strong></p><p>请求头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号<code>:</code>进行分隔。例如：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Content-Type: application/json</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Host: www.abc.com</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>请求体</strong></p><p>请求体中放置 POST、PUT、PATCH 等请求方法所需要携带的数据。</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="5-http-响应报文是什么样的">5. HTTP 响应报文是什么样的？<a class="hash-link" href="#5-http-响应报文是什么样的" title="Direct link to heading">​</a></h2><p>HTTP 响应报⽂的组成: 响应⾏、响应头、空⾏、响应体。</p><p><strong>响应行</strong></p><p>响应行由协议版本、状态码、状态码的原因短语 3 个内容组成，中间以空格分隔。例如：</p><div class="codeBlockContainer_J+bg language-bash theme-code-block"><div class="codeBlockContent_csEI bash"><pre tabindex="0" class="prism-code language-bash codeBlock_rtdJ thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#F8F8F2"><span class="token plain">HTTP/1.1 </span><span class="token number">200</span><span class="token plain"> OK</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>响应头</strong></p><p>响应头由键值对组成，每⾏⼀对，键值之间⽤英⽂冒号<code>:</code>进行分隔。例如：</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#F8F8F2"><span class="token plain">Content-Length: 1024</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">Content-Type: application/json</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><strong>响应体</strong></p><p>服务器发送过来的数据。</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="6-你了解的-http-状态码有哪些">6. 你了解的 HTTP 状态码有哪些？<a class="hash-link" href="#6-你了解的-http-状态码有哪些" title="Direct link to heading">​</a></h2><p><strong>成功（2XX）</strong></p><table><thead><tr><th>状态码</th><th>原因短语</th><th>说明</th></tr></thead><tbody><tr><td><strong>200</strong></td><td>OK</td><td>表示从客户端发来的请求在服务器端被正确处理</td></tr><tr><td><strong>201</strong></td><td>Created</td><td>请求已经被实现，⽽且有⼀个新的资源已经依据请求的需要⽽建⽴, 通常是在 POST 请求，或是某些 PUT 请求之后创建了内容, 进行的返回的响应 , 规范的后台一般有这个</td></tr><tr><td>202</td><td>Accepted</td><td>请求服务器已接受，但是尚未处理，不保证完成请求, 适合异步任务或者说需要处理时间比较长的请求，避免 HTTP 连接一直占用 . 比如检索服务端是否存在某数据</td></tr><tr><td>204</td><td>No content</td><td>表示请求成功，但响应报⽂不含实体的主体部分</td></tr><tr><td><strong>206</strong></td><td>Partial Content</td><td>进⾏的是范围请求, 表示服务器已经成功处理了部分 GET 请求, 响应头中会包含获取的内容范围 (常用于分段下载) , 断点续传</td></tr></tbody></table><p><strong>重定向（3XX）</strong></p><table><thead><tr><th>状态码</th><th>原因短语</th><th>说明</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td>永久性重定向，表示资源已被分配了新的 URL<br>比如，我们访问 <strong>http</strong>://<a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">www.baidu.com</a> 会跳转到 <strong>https</strong>://<a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">www.baidu.com</a></td></tr><tr><td>302</td><td>Found</td><td>临时性重定向，表示资源临时被分配了新的 URL, 支持搜索引擎优化<br>比如一开始访问首页, 遇到了需要登录才能操作的内容, 此时要重定向到登录页或其他页面, 但是登录成功之后还是要回去</td></tr><tr><td>303</td><td>See Other</td><td>对于 POST 请求，它表示请求已经被处理，客户端可以接着使用 GET 方法去请求 Location 里的 URI。</td></tr><tr><td><strong>304</strong></td><td><strong>Not Modified</strong></td><td><strong>自从上次请求后，请求的网页内容未修改过。<br>服务器返回此响应时，不会返回网页内容。(协商缓存)</strong></td></tr><tr><td>307</td><td>Temporary Redirect</td><td>对于 POST 请求，表示请求还没有被处理，客户端应该向 Location 里的 URI 重新发起 POST 请求。</td></tr></tbody></table><p>因为 post 请求, 是非幂等的, 从 302 中, 细化出了 303 和 307</p><p>非幂等大概意思是我已经提交一次, 再提交一次的结果就不一样了. 303 告诉 Post 请求已经被处理过了, 下一次就不要发 post 了, 使用 get 就可以</p><p>307 表示不对请求做额外处理, 正常发送请求, 请求 location 中的 url 地址</p><p>协商缓存: 假设缓存时间到了, 过期那就重新获取资源, 但是存在这样的情况: 虽然过期了, 但是和服务端的内容其实还是一样的, 没必要再重请求资源. 此时发请求去问服务端: 我这里资源过期了, 现在手里的资源还能用吗? 服务器查了之后告诉客户端没过期 还能用.</p><p>简而言之:</p><ul><li>301 302 307 都是重定向 303 因为会改变请求方式所以用的少</li><li>304 协商缓存</li></ul><p><strong>客户端错误（4XX）</strong></p><table><thead><tr><th>状态码</th><th>原因短语</th><th>说明</th></tr></thead><tbody><tr><td><strong>400</strong></td><td><strong>Bad Request</strong></td><td><strong>请求报⽂存在语法错误(（传参格式不正确）</strong></td></tr><tr><td>401</td><td>UnAuthorized</td><td>权限认证未通过(没有权限)</td></tr><tr><td>403</td><td>Forbidden</td><td>表示对请求资源的访问被服务器拒绝</td></tr><tr><td>404</td><td>Not Found</td><td>表示在服务器上没有找到请求的资源</td></tr><tr><td>408</td><td>Request Timeout</td><td>客户端请求超时</td></tr><tr><td>409</td><td>Confict</td><td>请求的资源可能引起冲突</td></tr></tbody></table><p><strong>服务端错误（5XX）</strong></p><table><thead><tr><th>状态码</th><th>原因短语</th><th>说明</th></tr></thead><tbody><tr><td>500</td><td>Internal Sever Error</td><td>表示服务器端在执⾏请求时发⽣了错误</td></tr><tr><td>501</td><td>Not Implemented</td><td>请求超出服务器能⼒范围，例如服务器不⽀持当前请求所需要的某个功能，<br>或者请求是服务器不⽀持的某个⽅法</td></tr><tr><td>503</td><td>Service Unavailable</td><td>表明服务器暂时处于超负载或正在停机维护，⽆法处理请求</td></tr><tr><td>505</td><td>Http Version Not Supported</td><td>服务器不⽀持，或者拒绝⽀持在请求中使⽤的 HTTP 版本</td></tr></tbody></table><h2 class="anchor anchorWithStickyNavbar_y2LR" id="7-http-的-keep-alive-是什么作用">7. HTTP 的 keep-alive 是什么作用？<a class="hash-link" href="#7-http-的-keep-alive-是什么作用" title="Direct link to heading">​</a></h2><p>作用：使客户端到服务器端的连接<strong>持续有效</strong>(长连接)，当出现对服务器的后继请求时，</p><p>Keep-Alive 功能避免了建立或者重新建立连接。</p><p>早期 HTTP/1.0 在每次请求的时候，都要创建⼀个新的连接，⽽创建连接的过程需要消耗资源和时间，</p><p>为了减少资源消耗、缩短响应时间，就需要复⽤已有连接。</p><p>在后来的 HTTP/1.0 以及 HTTP/1.1 中引⼊了复⽤连接的机制，也就是在请求头中加⼊ Connection: keep-alive，</p><p>以此告诉对⽅这个请求响应完成后不要关闭连接，下⼀次还⽤这个请求的连接进行后续交流。</p><p><strong>协议规定，如果想要保持连接，则需要在请求头中加上 Connection: keep-alive。</strong></p><p><strong>keep-alive 的优点</strong> (复用连接)</p><ul><li>较少的 CPU 和内存的占⽤（因为要打开的连接数变少了, 复用了连接）</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）</li><li>...</li></ul><p>缺点: 因为在处理的暂停期间，本来可以释放的资源仍旧被占用。请求已经都结束了, 但是还一直连接着也不合适</p><p>解决：Keep-Alive: timeout=5, max=100</p><ul><li><p>timeout：过期时间 5 秒（对应 httpd.conf 里的参数是：KeepAliveTimeout），</p></li><li><p>max 是最多一百次请求，强制断掉连接。</p><p>就是在 timeout 时间内又有新的连接过来，同时 max 会自动减 1，直到为 0，强制断掉。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_y2LR" id="8-为什么需要-https">8. 为什么需要 HTTPS？<a class="hash-link" href="#8-为什么需要-https" title="Direct link to heading">​</a></h2><p>HTTPS 是安全版的 HTTP。</p><p>HTTP 协议在传输数据时采用的是明⽂方式传递，因此，⼀些敏感信息的传输就变得很不安全。</p><p>而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的。</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="9-https-是如何保证安全的">9. HTTPS 是如何保证安全的？<a class="hash-link" href="#9-https-是如何保证安全的" title="Direct link to heading">​</a></h2><p>HTTPS 在传输数据的过程中会对数据进行加密处理，保证安全性。</p><p>那 HTTPS 采用的什么样的加密方式呢？我们来了解下一些加密的基本概念。</p><p>目前常见的加密算法可以分成三类，<code>对称加密算法</code>，<code>非对称加密算法</code>和 <code>Hash 算法</code>。</p><ol><li>对称加密算法: 相同密钥加密解密, 可逆的, 可以用于加密解密传输数据, 想使用对称加密算法, 一定要保证密钥不被泄露(且进行密钥的传输约定时, 一定要保证安全, 所以我们用到了下面的非对称加密算法)</li><li>非对称算法: 有两把钥匙, 公钥和私钥, 可逆的, 可以用于 https 的初步交换密钥</li><li>hash 算法: 不可逆的, 根据一段内容, 生成一段唯一标识, 一般用于验证数据是否被修改</li></ol><h3 class="anchor anchorWithStickyNavbar_y2LR" id="91-什么是对称加密">9.1 <strong>什么是对称加密？</strong><a class="hash-link" href="#91-什么是对称加密" title="Direct link to heading">​</a></h3><p>对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，一般是可逆的</p><p>这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难</p><p>通信的双⽅都使⽤同⼀个秘钥进⾏加解密。⽐如，两个人事先约定的暗号，就属于对称加密。</p><p><img alt="image-20210306005550796" src="/assets/images/image-20210306005550796-fb35039a6bc0a30a7f974f98f4368e56.png"></p><p>对称加密的特点是：</p><ul><li><p>优点:</p><p>计算量小、加密速度快、加密效率高。</p></li><li><p>缺点:</p><p>在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。</p><p><code>如果一方的秘钥被泄露，那么加密信息也就不安全了</code></p></li></ul><p>使用场景：本地数据加密、https 通信、网络传输等</p><p>常见算法：AES、DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>那如何确定密钥是什么, 如何建立密钥约定, 所以涉及密钥传输问题, 也就是非对称加密来解决该问题</p></div></div><h3 class="anchor anchorWithStickyNavbar_y2LR" id="92-什么是对称加密">9.2 <strong>什么是⾮对称加密？</strong><a class="hash-link" href="#92-什么是对称加密" title="Direct link to heading">​</a></h3><p>而加密和解密其实可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，</p><p>这样就避免了直接传递密钥。这种新的加密模式被称为&quot;非对称加密算法&quot;。</p><p>通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。</p><p>特征: 私钥可以解密公钥加密的内容, 公钥可以解密私钥加密的内容</p><p><img alt="image-20210306011528361" src="/assets/images/image-20210306011528361-debb1ae9268964238b3d278e63cb04b5.png"></p><p>非对称加密的特点是：</p><ul><li><p>优点：非对称加密与对称加密相比其安全性更好</p></li><li><p>缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p></li></ul><p>使用场景：https 会话前期、CA 数字证书、信息加密、登录认证等</p><p>常见算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="93-https-加密解决案">9.3 <strong>HTTPS 加密解决⽅案</strong><a class="hash-link" href="#93-https-加密解决案" title="Direct link to heading">​</a></h3><p>结合了两种加密⽅式：</p><ul><li><p>将 <code>对称加密的密钥(一串约定的字符串)</code> ⽤非对称加密的公钥, 进⾏加密并发送出去，接收⽅使⽤私钥解密得到 <code>对称加密密钥</code></p></li><li><p>双⽅沟通时使⽤ <code>对称加密密钥</code> 进⾏</p></li></ul><p><strong>可以看到，只有在发送秘钥阶段才使用非对称加密，而后续的通信都使用对称加密，这样解决了性能问题。</strong></p><p>HTTPS 目前所使用的 TLS 或 SSL 协议, 就是目前采用的加密通道的规范协议</p><p>它利用对称加密、(公私钥)非对称加密, 以及其密钥交换算法，可完成可信任的信息传输</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="94-数字证书">9.4 数字证书<a class="hash-link" href="#94-数字证书" title="Direct link to heading">​</a></h3><p>为了安全性, 一般还需要签发数字证书!</p><p>客户端 和 服务器端要初步互通消息时, 客户端发送请求可以拿到公开的公钥信息</p><p>进而进行非对称加密, 使用公钥, 加密<code>对称加密密钥</code>, 传递给服务器, 后续通信都使用对称加密!</p><p><strong>问题是: 初步互通消息时, 如果请求拿到的公钥信息, 就是假的, 或者不安全的! 那么后续的所有操作, 都将是不安全的!</strong></p><p>如何保证公钥的安全性呢? 比如访问百度和淘宝, 他们俩都会分别给公钥, 对于浏览器来说谁给我不重要, 重要的是我要知道百度给的钥匙是不是百度给的, 淘宝给的钥匙是不是淘宝给的. 那怎么确认是淘宝给的, 不是别人给的,</p><p>所以, 就需要有数字证书(CA 证书), 一般是 CA 机构(具有公信力的机构 )颁发的, 证明这个公钥是安全可靠的!</p><p><strong>CA 证书中心会对你网站的公钥, 网站的域名地址, 证书到期时间, 等一些相关信息一起加密签发数字证书, 保证你网站的安全性</strong></p><p>当公司申请了 CA 证书后, 就应该在响应时, 将数字证书(证书里包含公钥)一起发送给客户端</p><p>而客户端, 接收到消息后, 就可以查看证书</p><ol><li><p>如果正在访问的网站 和 证书记载的网址 不一致, 说明不安全, 可能被冒用, 浏览器就会发出警告!!!</p></li><li><p>如果签发证书的机构, 不权威, 发出警告</p></li><li><p>如果证书过期了, 浏览器也会发出警告</p></li></ol><h3 class="anchor anchorWithStickyNavbar_y2LR" id="95-数字签名">9.5 数字签名<a class="hash-link" href="#95-数字签名" title="Direct link to heading">​</a></h3><p>但这还是有问题：如果证书被篡改了怎么办?</p><p>这时就需要用⼀个技术：<strong>数字签名</strong>。 (根据证书内容, 生成的一个唯一标识)</p><p>数字签名就是先⽤ <strong>CA ⾃带的 Hash 算法来计算出证书内容的⼀个摘要</strong>，然后使⽤ CA 私钥进行加密，组成数字签名。</p><p>当别⼈把他的证书发过来时，<strong>接收方⽤同样的算法再次⽣成摘要</strong>，⽤ CA 公钥解密后得到 CA 生成的摘要，两者进行对⽐后,</p><p>就能确定中间是否被⼈篡改。这样就能最⼤程度的保证通信的安全了。</p><p><a href="https://blog.csdn.net/u014044812/article/details/80723009" target="_blank" rel="noopener noreferrer">博客参考</a></p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="简要小结">简要小结<a class="hash-link" href="#简要小结" title="Direct link to heading">​</a></h3><ol><li>为什么需要 https?</li></ol><ul><li>因为 http 是明文传输的, 不安全, 而 https 是会对内容加密的</li></ul><ol start="2"><li>https 的加密策略是什么?</li></ol><ul><li>先用 非对称加密, 传递对称加密的密钥(保证了密钥传输的安全)</li><li>后续使用 对称加密, 进行交流(保证了传输数据的安全)</li></ul><ol start="3"><li>问题: 就算第一次交流是用非对称加密, 公钥也是要在网络中传输的, 比如 vpn. 如何证明公钥是可靠的? 如何证明网站是可靠的?</li></ol><ul><li>需要 CA 机构认证, 网站需要申请数字证书, 请求网站时, 网站会将数字证书给到浏览器, 浏览器默认会检测证书的可靠性. 如何检测 看是否是权威机构发布的, 看证书中记录的地址和当前访问的网站的地址, 是否一致, 只有一致才可靠, 看证书是否过期</li></ul><ol start="4"><li>如何保证证书不被篡改 =&gt; 通过数字签名, 可以根据证书的所有内容, 生成一个唯一标识, 一旦内容如果被修改了, 再次生成唯一标识时, 和之前生成的唯一标识就不一样(hash 加密算法), 检测是否被修改</li></ol><h2 class="anchor anchorWithStickyNavbar_y2LR" id="10-http2-和-http1x-比有什么优势和特点">10. HTTP2 和 HTTP1.x 比，有什么优势和特点？<a class="hash-link" href="#10-http2-和-http1x-比有什么优势和特点" title="Direct link to heading">​</a></h2><ol><li>HTTP/2 采⽤<code>⼆进制格式</code>来传输数据，⽽⾮ HTTP 1.x 的⽂本格式，⼆进制协议<code>解析起来更⾼效</code></li><li>HTTP/2 采用一些<code>头部压缩技术</code>，减少在请求和响应头中重复携带的数据，<code>降低网络负担</code></li><li>HTTP/2 采⽤<code>服务器推送</code>方式，主动向客户端推送资源，提高页面加载效率</li><li>HTTP/2 采⽤<code>多路复用机制</code>，减少需要创建的连接数量，降低资源占用和性能消耗</li></ol><p>下面是一些与之关联的技术知识。</p><p><strong>⼆进制格式分帧</strong></p><p>帧：HTTP/2 数据通信的最⼩单位消息，是指 HTTP/2 中逻辑上的 HTTP 消息（例如请求、响应等）。消息由⼀个或多个帧组成</p><p>流：存在于连接中的⼀个虚拟通道，它可以承载双向消息，且每个流都有唯⼀的整数 ID</p><p><strong>头部压缩</strong></p><p>在 HTTP/1.x 中，请求和响应中会重复携带一些不常改变、冗⻓的头数据，给⽹络带来额外负担。</p><p>在 HTTP/2 中，客户端和服务端使⽤ <strong>“⾸部表”</strong> 来跟踪和存储之前发送过的键值对，</p><p>相同的数据不再随着每次请求和响应发送。⾸部表在连接存续期间始终存在，由客户端和服务器共同渐进更新。</p><p>每个新的⾸部键值对，要么被追加到当前表的末尾，要么替换表中已存在的键值对。</p><blockquote><p>可以简单的理解为：只发送差异数据，⽽不是全部发送，从⽽减少头部的信息量</p></blockquote><p><strong>服务器推送</strong></p><p>服务端可以在发送⻚⾯ HTML 内容时，再主动推送一些其它资源，⽽不⽤等到浏览器解析到相应的位置时发起请求后再作响应。</p><p>例如，服务端可以主动把 JS 和 CSS ⽂件推送给客户端，⽽不需要客户端解析 HTML 时再发送这些请求。</p><p>不过，服务端的主动推送行为，客户端有权利选择是否要接收。</p><p>如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 RST_STREAM 帧来拒收。</p><p><strong>多路复用</strong></p><p>在 HTTP 1.x 中如果想并发多个请求的话，必须使⽤多个 TCP 链接，但浏览器为了控制资源，</p><p>会对单个域名有 6-8 个 TCP 链接的数量限制。而在 HTTP 2 中：</p><ul><li>同域名下的所有通信，都在单个连接上完成</li><li>单个连接可以承载任意数量的双向数据流</li><li>数据流以消息的形式发送，⽽消息⼜由⼀个或多个帧组成（多个帧可以乱序发送，因为可以根据帧⾸部的流标识来重新组装）</li></ul><p><a href="https://zhuanlan.zhihu.com/p/30166894" target="_blank" rel="noopener noreferrer">参考文章：HTTP/2 特性及其在实际应用中的表现</a></p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="11-http-缓存控制">11. http 缓存控制<a class="hash-link" href="#11-http-缓存控制" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_y2LR" id="111-基本认知">11.1 基本认知<a class="hash-link" href="#111-基本认知" title="Direct link to heading">​</a></h3><p><strong>Web 服务缓存</strong> 大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 服务器缓存）、浏览器缓存。</p><p><strong>浏览器缓存</strong> 也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。<strong><code>这里我们只讨论 HTTP 缓存相关内容</code>。</strong></p><p><strong>HTTP 缓存</strong>:</p><ul><li><strong>强缓存</strong></li><li><strong>协商缓存</strong></li></ul><p>在具体了解 HTTP 缓存之前先来明确几个术语：</p><ul><li>缓存命中率：从缓存中得到数据的请求数 与 所有请求数的比率。理想状态是越高越好。</li><li>过期内容：超过设置的有效时间，被标记为“陈旧”的内容。</li><li>验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。</li><li>失效：失效就是把内容从缓存中移除。</li></ul><p><strong>浏览器缓存主要是 HTTP 协议定义的缓存机制。</strong></p><p><strong>浏览器缓存, HTTP 缓存分类</strong></p><p>浏览器缓存分为<code>强缓存 </code>和 <code>协商缓存</code>，浏览器加载一个页面的简单流程如下：</p><ol><li><p>浏览器先根据这个资源的 <strong>http 头信息</strong> 来 <strong>判断是否命中强缓存</strong>。</p><p>如果命中则直接加载在缓存中的资源，并不会将请求发送到服务器。（强缓存）</p></li><li><p>如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。</p><p>服务器来判断浏览器本地缓存是否失效。</p><p>若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）</p></li><li><p>如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）</p></li></ol><h3 class="anchor anchorWithStickyNavbar_y2LR" id="112-强缓存-食品过期时间判断">11.2 强缓存 (食品过期时间判断)<a class="hash-link" href="#112-强缓存-食品过期时间判断" title="Direct link to heading">​</a></h3><p><strong>(进行判断, 是否资源过期, 如果未过期, 直接用缓存)</strong></p><p><strong>强缓存</strong></p><p>命中强缓存时，浏览器并不会将请求发送给服务器。</p><p>在 Chrome 的开发者工具中看到 http 的返回码是 200，但是在 Size 列会显示为(from cache)。</p><p><img alt="img" src="/assets/images/940884-20180423141536107-329179455-60140c66fa06192b6ffb265ba9b397b0.png"></p><p>强缓存是利用 http 的返回的响应头中的 Expires 或者 Cache-Control (优先级更高) 两个字段来控制的，用来表示资源的缓存时间。</p><p>Expires: 指定一个具体时间(2020 年 12 月 12 日 17:00), 到了这个时间了, 缓存过期了, 在时间内, 都是有效的, 可以直接读</p><p>Cache-Control : 指定一个过期时间 (3600s), 这个资源你加载到后, 可以用 3600s</p><p><strong>Expires</strong></p><p><code>存在的问题是浏览器与服务器时间不一定一致</code></p><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和 Last-modified 结合使用。但在上面我们提到过，cache-control 的优先级更高。</p><p>Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p>该字段会返回一个时间，比如 Expires: Wed, 23 Nov 2050 16:00:01 GMT 。这个时间代表着这个资源的失效时间，也就是说在 xx 年 xx 月 xx 日时间之前都是有效的，即命中缓存。</p><p>这种方式有一个明显的缺点，由于失效时间是一个<code>绝对时间</code>，所以当 <strong>服务器与客户端 时间偏差很大</strong> 以后，就会导致缓存混乱。于是发展出了 Cache-Control。</p><p><strong>Cache-Control</strong></p><p>Cache-Control 是一个<code>相对时间</code>，例如 Cache-Control:max-age 3600，代表着资源的有效期是 3600 秒。</p><p>由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。</p><p>Cache-Control 与 Expires 可以在服务端配置同时启用或者启用任意一个，同时启用的时候 Cache-Control 优先级高。</p><p>Cache-Control 可以由多个字段组合而成，主要有以下几个取值：</p><ol><li><p><strong>max-age</strong> 指定一个时间长度，在这个时间段内缓存是有效的，单位是 s。</p><p>例如设置 Cache-Control:max-age=31536000，也就是说缓存有效期为（31536000 / 24 / 60 / 60）天，</p><p>第一次访问这个资源的时候，服务器端也返回了 Expires 字段，并且过期时间是一年后。</p><p>在没有禁用缓存并且没有超过有效时间的情况下，再次访问这个资源就命中了缓存，不会向服务器请求资源而是直接从浏览器缓存中取。</p></li><li><p><strong>no-cache</strong> 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证的请求到服务器, 问服务器是否可以读缓存。</p><p>不是字面意思上的不缓存。</p></li><li><p><strong>no-store</strong> 禁止缓存，每次请求都要向服务器重新获取数据。</p></li></ol><p>注意: 如果命中强缓存, 在有效期内, 使用了本地浏览器的缓存, 请求该资源是不会向服务器发送请求的! (大大减轻了服务器压力)</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="113-协商缓存-强缓存未命中-发送请求进行协商">11.3 协商缓存 (强缓存未命中-发送请求进行协商)<a class="hash-link" href="#113-协商缓存-强缓存未命中-发送请求进行协商" title="Direct link to heading">​</a></h3><p>看看过期时间, 食品没过期, 直接吃 (直接读缓存, 不发请求) 命中强缓存!</p><p>食品过期时间过了, 能不能吃呢? 问问专家(服务器), 专家瞅了一眼, 还能吃, 不会死人, 重新标了个过期时间(有科学依据)</p><p>(响应 304, 不返回内容) , 可以用 (协商缓存)</p><p>如果问过专家(服务器), 专家瞅了一眼, 呀真不能用了, 原来的不要了, 我重新给你发一个 (响应 200, 并返回内容)</p><p><strong>协商缓存</strong></p><p>若未命中强缓存(强缓存过期了)，则浏览器会将请求发送至服务器。</p><p>服务器根据 http 头信息中的<code>Last-Modify/If-Modify-Since</code>或<code>Etag/If-None-Match</code>来判断是否命中协商缓存。</p><p>如果命中，则 http 返回码为 304 (你本地之前加载的资源是有效的)，浏览器从缓存中加载资源。</p><p><strong>Last-Modify/If-Modify-Since</strong></p><p>浏览器第一次请求一个资源的时候, 服务器返回的 header 中会加上 Last-Modify，</p><p>Last-modify 是一个时间标识该资源的<strong>最后修改时间</strong>，例如<code>Last-Modify: Thu,31 Dec 2037 23:59:59 GMT</code>。</p><p>当浏览器再次请求该资源时(进行协商请求时)，发送的请求头中会包含 If-Modify-Since，<strong>该值为缓存之前返回的 Last-Modify</strong>。</p><p>服务器收到 If-Modify-Since 后，根据实际服务器的资源的最后修改时间, 进行判断是否命中缓存。</p><p>如果命中缓存，则返回 <strong>http304</strong>，并且不会返回资源内容，并且不会返回 Last-Modify。</p><p><img alt="image-20210308123308326" src="/assets/images/image-20210308123308326-7293323c60120b63aa0c189c0f3f261e.png"></p><p>由于对比的是<strong>服务端的修改时间</strong>，所以就算客户端与服务端时间差距, 也不会有问题。</p><p><strong>但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。</strong></p><p>比如: 最后修改只能精确到秒级, 一秒进行了多次修改, 就不行了, <strong>于是出现了 ETag/If-None-Match。</strong></p><p><strong>ETag/If-None-Match</strong></p><p>与 Last-Modify/If-Modify-Since (最后修改时间)不同的是，Etag/If-None-Match 返回的是一个校验码（ETag: entity tag）。</p><p>ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化。</p><p>ETag 值的变更则说明资源状态已经被修改。</p><p>服务器根据浏览器上发送的 If-None-Match 值来判断是否命中缓存。</p><p><img alt="etag" src="/assets/images/940884-20180423141918779-1206116367-2f3d7f4aed868c86649a4175f6b125b7.png"></p><p>ETag 生成靠以下几种因子</p><ol><li><p>文件的 i-node 编号，是 Linux/Unix 用来识别文件的编号。</p></li><li><p>文件最后修改时间</p></li><li><p>文件大小</p></li></ol><p>生成 Etag 的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。生成一个标记文件的唯一值</p><p><strong>既生 Last-Modified 何生 Etag ？</strong></p><p>你可能会觉得使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 Etag（实体标识）呢？</p><p>Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题：</p><ol><li><p>Last-Modified 标注的最后修改只能精确到秒级</p><p>如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p></li><li><p>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p></li></ol><p>Etag 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加 <strong>准确的控制缓存。</strong></p><p>不会仅仅只根据最后的修改时间判断是否进行使用缓存</p><p>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，</p><p>最后才决定是否返回 304。</p><p>小结:</p><ul><li><p>强缓存: 大大的减少了 服务器的请求次数, 在过期时间内, 直接从客户端内存中读</p></li><li><p>协商缓存: 强缓存命中失效了, 超过过期时间了, 拿着标识(最后的修改时间, 唯一标识 etag), 去问服务器, 是否真的过期了</p><p>如果验证通过, 服务器会直接响应 304, 且不会返回资源</p></li></ul><h3 class="anchor anchorWithStickyNavbar_y2LR" id="114-整体请求缓存流程">11.4 整体请求缓存流程<a class="hash-link" href="#114-整体请求缓存流程" title="Direct link to heading">​</a></h3><p><strong>浏览器第一次请求</strong></p><p><img alt="83532090" src="/assets/images/940884-20180423141945261-83532090-a897133a2c06cfdaf6b4b95c40bbac90.png"></p><p><strong>浏览器第二次请求</strong></p><p><img alt="912699213" src="/assets/images/940884-20180423141951735-912699213-156a4371666604602da6746148b11b75.png"></p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>注意看HTTP协议-整体巩固</p></div></div><hr></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/aokikoko/aokikoko.github.io/blob/main/website/docs/interview/HTTP.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/React/redux"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">[React] redux</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/interview/js"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">[面试题] JS</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-http-有哪些方法" class="table-of-contents__link toc-highlight">1. HTTP 有哪些方法？</a></li><li><a href="#2-各个-http-方法的具体作用是什么" class="table-of-contents__link toc-highlight">2. 各个 HTTP 方法的具体作用是什么？</a></li><li><a href="#3-get-方法和-post-方法有何区别" class="table-of-contents__link toc-highlight">3. GET 方法和 POST 方法有何区别？</a></li><li><a href="#4-http-请求报文是什么样的" class="table-of-contents__link toc-highlight">4. HTTP 请求报文是什么样的？</a></li><li><a href="#5-http-响应报文是什么样的" class="table-of-contents__link toc-highlight">5. HTTP 响应报文是什么样的？</a></li><li><a href="#6-你了解的-http-状态码有哪些" class="table-of-contents__link toc-highlight">6. 你了解的 HTTP 状态码有哪些？</a></li><li><a href="#7-http-的-keep-alive-是什么作用" class="table-of-contents__link toc-highlight">7. HTTP 的 keep-alive 是什么作用？</a></li><li><a href="#8-为什么需要-https" class="table-of-contents__link toc-highlight">8. 为什么需要 HTTPS？</a></li><li><a href="#9-https-是如何保证安全的" class="table-of-contents__link toc-highlight">9. HTTPS 是如何保证安全的？</a><ul><li><a href="#91-什么是对称加密" class="table-of-contents__link toc-highlight">9.1 <strong>什么是对称加密？</strong></a></li><li><a href="#92-什么是对称加密" class="table-of-contents__link toc-highlight">9.2 <strong>什么是⾮对称加密？</strong></a></li><li><a href="#93-https-加密解决案" class="table-of-contents__link toc-highlight">9.3 <strong>HTTPS 加密解决⽅案</strong></a></li><li><a href="#94-数字证书" class="table-of-contents__link toc-highlight">9.4 数字证书</a></li><li><a href="#95-数字签名" class="table-of-contents__link toc-highlight">9.5 数字签名</a></li><li><a href="#简要小结" class="table-of-contents__link toc-highlight">简要小结</a></li></ul></li><li><a href="#10-http2-和-http1x-比有什么优势和特点" class="table-of-contents__link toc-highlight">10. HTTP2 和 HTTP1.x 比，有什么优势和特点？</a></li><li><a href="#11-http-缓存控制" class="table-of-contents__link toc-highlight">11. http 缓存控制</a><ul><li><a href="#111-基本认知" class="table-of-contents__link toc-highlight">11.1 基本认知</a></li><li><a href="#112-强缓存-食品过期时间判断" class="table-of-contents__link toc-highlight">11.2 强缓存 (食品过期时间判断)</a></li><li><a href="#113-协商缓存-强缓存未命中-发送请求进行协商" class="table-of-contents__link toc-highlight">11.3 协商缓存 (强缓存未命中-发送请求进行协商)</a></li><li><a href="#114-整体请求缓存流程" class="table-of-contents__link toc-highlight">11.4 整体请求缓存流程</a></li></ul></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.8d5656ef.js"></script>
<script src="/assets/js/main.0a6693fb.js"></script>
</body>
</html>